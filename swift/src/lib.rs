//! # Swift Engine
//!
//! A discrete event simulation engine with optimal incremental simulation, parallelism, and caching.

use crate::exec::{ExecEnvironment, SyncBump, EXECUTOR, NUM_THREADS};
use serde::de::DeserializeOwned;
use serde::{Deserialize, Serialize};
use std::fmt::Debug;
use std::ops::RangeBounds;
pub use swift_macros::{activity, model};
pub mod exec;
pub mod history;
pub mod operation;
pub mod reexports;
pub mod timeline;

pub use hifitime::Duration;
pub use hifitime::Epoch as Time;
use history::HasHistory;
use timeline::HasResource;

/// Marks a type as a resource label.
///
/// This is not applied to the actual data and is never instantiated, because multiple resources
/// might have the same representation. (i.e. both memory usage and battery state are f32's.)
///
/// Resources are not part of a model, the model is a selection of existing resources. This allows
/// activities, which are also not part of a model, to be applied to any model that has the relevant
/// resources.
pub trait Resource<'h>: 'static + Sized + Debug {
    /// Whether the resource represents a value that can vary even when not actively written to by
    /// an operation. This is used for cache invalidation,
    /// so it is very important not to give false positives.
    ///
    /// The basic question is "does it matter
    /// how long it has been since this resource was last written to?" For a boolean resource, the
    /// answer is "no", and so it is static. But for a continuously-varying linear function,
    /// the answer is "yes"; the value it represents changes over time even in between operations.
    const STATIC: bool;

    /// The type that is read from history.
    type Read: 'h + Copy + Send + Sync + Serialize;

    /// The type that is written from operations to history.
    type Write: 'static
        + From<Self::Read>
        + Clone
        + Default
        + Debug
        + Serialize
        + DeserializeOwned
        + Send
        + Sync;

    type History: HasHistory<'h, Self> + Default;
}

/// The interface that plan objects provide.
///
/// ## Constructing
///
/// The [model] macro, when applied to a model struct `MyModel`, will also generate a type called
/// `MyModelPlan`, that implements this trait. It can be created with `MyModel::new_plan`.
pub trait Plan<'o>: Sync
where
    Self: 'o,
{
    type Model: Model<'o>;

    /// Inserts a new activity into the plan, and returns its unique ID.
    fn insert(
        &mut self,
        start_time: Time,
        activity: impl Activity<'o, Self::Model> + 'o,
    ) -> ActivityId;

    /// Removes an activity from the plan, by ID.
    fn remove(&self, id: ActivityId);

    /// Returns a view into a section of a resource's timeline. After creating a plan, call
    /// `plan.view::<MyResource>(start..end, &histories)` to get a vector of times and values
    /// within the `start - end` range.
    ///
    /// Try to limit the requested range to only the times that you need.
    ///
    /// The histories struct will be autogenerated by the [model] macro.
    fn view<R: Resource<'o>>(
        &self,
        bounds: impl RangeBounds<Time>,
        histories: &'o <Self::Model as Model<'o>>::Histories,
    ) -> Vec<(Time, R::Read)>
    where
        Self: HasResource<'o, R>,
    {
        let bump = SyncBump::new();
        let nodes = self.get_operations(bounds).into_iter();
        let env = ExecEnvironment::new(&bump);
        std::thread::scope(move |scope| {
            // EXPLANATION:
            // The async executor crate provides an `executor.run(fut)` function,
            // that runs the executor until `fut` completes. Importantly, if `fut` yields,
            // the executor will keep doing other submitted tasks until `fut` wakes,
            // even if they are unrelated.

            // If `fut` is, say, awaiting an async shutdown signal, then the executor
            // will keep doing any other available tasks until the shutdown signal is received.
            // The following line creates that shutdown signal. It will be sent when
            // `_signal` goes out of scope, which will only happen after all the
            // tasks we actually care about are complete.
            let (_signal, shutdown) = async_channel::bounded::<()>(1);

            for _ in 0..NUM_THREADS {
                let shutdown = shutdown.clone();
                scope.spawn(move || futures::executor::block_on(EXECUTOR.run(shutdown.recv())));
            }

            futures::executor::block_on(futures::future::join_all(
                nodes.map(|(t, n)| async move { (t, *n.read(histories, env).await.1) }),
            ))
        })
    }
}

/// A selection of resources, with tools for creating a plan and storing history.
///
/// Autogenerated by the [model] macro.
pub trait Model<'o>: Sync {
    type Plan: Plan<'o, Model = Self>;
    type InitialConditions;
    type Histories: 'o + Sync + Default + Debug;

    /// Creates a new plan instance, given a start time, initial conditions, and an allocator.
    fn new_plan(
        time: Time,
        initial_conditions: Self::InitialConditions,
        bump: &'o SyncBump,
    ) -> Self::Plan;
}

/// An activity, which decomposes into a statically-known set of operations. Implemented
/// with the [activity] macro.
pub trait Activity<'o, M: Model<'o>>: Send + Sync {
    fn decompose(&'o self, start: Time, plan: &mut M::Plan, bump: &'o SyncBump);
}

/// A unique activity ID.
#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub struct ActivityId(u32);
impl ActivityId {
    pub fn new(id: u32) -> ActivityId {
        ActivityId(id)
    }
}
