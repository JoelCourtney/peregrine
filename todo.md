# TODOs for Claude

- [x] Compare the existing submodels that I've already converted with the originals. Until recently I didn't have the ability to specify resource value defaults at the model level. Find resources that have non-trivial defaults in the Java version and make sure they have the same default in the Rust version.
- [x] A functionality to the model! macro so that when declaring a reactive daemon, you can use `react(*) ...` instead of `react(list, of, resources) ...` to make the daemon react to all resources in the model.
- [x] Convert the resource! macro from macro_rules to a procedural macro in the peregrine_macros crate. Follow the same mod.rs/input.rs/output.rs structure that the model and operation macros use. When converting, use `peregrine::` in place of `$crate::`. After all tests pass, simplify the part of the model macro that parses and outputs resources by reusing the new parsing you just implemented. The model macro should parse a Resource object from the tokenstream, then put it in the output. We will need to be able to inspect the fields of the Resource object inside the model macro during a later step.
- [ ] Implement a feature called resources groups. These are sets of resources with the same associated data type that share a prefix. Example syntax:
  ```
  resource! {
    pub heater_*_active: bool = false; {a, b}
  }
  ```
  This would generate two resources as if they had written:
  ```
  resource! {
    pub heater_a_active: bool = false;
    pub heater_b_active: bool = false;
  }
  ```
  So basically the resource macro should look for an asterisk in the tokenstream (it can occur at the beginning, middle, or end of the identifier), and if one is found, parse the later parameters and do some string interpolation. Write integration tests to make sure this works. The resource! macro should also accept specific initial conditions for each resource in a group, with the following syntax:
  ```
  resource! {
    pub heater_*_active: bool; {
        a: false,
        b: true
    }
  }
  ```
  If an initial condition is supplied at the top level, it shouldn't be accepted for individual. Include these options in the tests.
- [ ] You just implemented resource group parsing in the resource! macro. Now generate an enum for the whole group of resources. Using the previous example, 
  ```
  resource! {
    pub heater_*_active: bool = false; {a, b}
  }
  ```
  would additionally generate an enum:
  ```
  #[derive(VariantsStruct, Copy, Clone, Eq, PartialEq, Debug, Sequence)]
  #[struct_derive(Debug, Data, MaybeHash, Serialize, Deserialize)]
  #[struct_bounds(MaybeHash, Data)]
  pub enum HeaterActive {
    A,
    B,
  }
  ```
  The enum should have the same visibility as the composite resource. You'll need to add dependencies on variants_struct 0.1.2 and enum-iterator 2.1.0 and expose them through peregrine::internal::macro_prelude. Note you will have to trim leading, trailing, or double underscores from the identifier; if you just strip the asterisk out you would get `heater__active`, when we want `heater_active`. VariantsStruct will generate a struct that looks like this:
  ```
  struct HeaterActiveStruct<T: MaybeHash + Data> {
    a: T,
    b: T
  }
  ```
  If you encounter any problems with VariantsStruct, stop and notify me. Make step-by-step plan for this before implementing.
- [ ] Create a `CompositeResource: Resource` trait next to the `Resource` trait. It'll have Resource as a supertrait and only add one associated type, `InnerData: for<'h> Data<'h>`. Implement `Resource` and `CompositeResource` for composite resources in the `resource!` macro, setting `Data = HeaterActiveStruct<bool>` (for example, where `HeaterActiveStruct` is the name of the struct generated by variants_struct on the `HeaterActive` enum, and bool was the type of all the inner resources), and `InnerData = bool`.
- [ ] The java version of the seis model has a function called updateChannelRates. Implement it as a reactive daemon in the rust version. Split the seis model 
